<#@ include file="EF.Reverse.POCO.Core.ttinclude" #>
<#@ import namespace="System.Windows.Forms" #>
<#@ import namespace="Tiger.Dal.Templates.DatabaseObjects" #>
<#@ import namespace="Tiger.Dal.Templates" #>

<#
	// v2.22.1
	// Please make changes to the settings below.
	// All you have to do is save this file, and the output file(s) is/are generated. Compiling does not regenerate the file(s).
	// A course for this generator is available on Pluralsight at https://www.pluralsight.com/courses/code-first-entity-framework-legacy-databases
	 
	// Main settings **********************************************************************************************************************
	ConnectionStringName = "LendDirect";	// Searches for this connection string in config files listed below in the ConfigFilenameSearchOrder setting
	//ConnectionStringName is the only required setting
	// Namespace = ""; // Override the default namespace here
	//DefaultConstructorArgument = "EnvironmentConnectionStrings.MyDbContext"; //defaults to "Name=" + ConnectionStringName
	
	TargetFrameworkVersion = "4.51"; // Please set this to your .NET framework version, 4.0, 4.5, 4.51, etc.
	ConfigFilenameSearchOrder = new[] { "app.config", "web.config", "app.config.transform", "web.config.transform" }; // Add more here if required. The config files are searched for in the local project first, then the whole solution second.

	Setting.DatabaseContextName = "POCTest";
	//Setting.DatabaseContextInterfaceName = "IMyDbContext"; //Defaults to "I" + Setting.DatabaseContextName
	Setting.ContextInterfaceBaseClass = "IDisposable";	 // Specify what the base classes are for your database context interface
	Setting.ContextBaseClass = "DbContext";	// Specify what the base class is for your DbContext. For ASP.NET Identity use "IdentityDbContext<ApplicationUser>"
	Setting.ConfigurationClassName = "Configuration"; // Configuration, Mapping, Map, etc. This is appended to the Poco class name to configure the mappings.
	Setting.MakeClassesPartial = true;
	Setting.MakeInterfacesPartial = true;
	Setting.MakeContextInterfacePartial = true;
	Setting.GenerateSeparateFiles = true;
	Setting.UseDataAnnotations = true; // Setting this to true will use DataAnnotations and false will use FluentAPI Configuration
	Setting.UseCamelCase = true;	 // This will rename the tables & fields to use CamelCase. If false table & field names will be left alone.
	Setting.IncludeComments = CommentsStyle.AtEndOfField; // Adds comments to the generated code
	Setting.DisableGeographyTypes = false; // Turns off use of System.Data.Entity.Spatial.DbGeography and System.Data.Entity.Spatial.DbGeometry as OData doesn't support entities with geometry/geography types.
	Setting.CollectionType = "System.Collections.Generic.IEnumerable";  // Determines the type of collection for the Navigation Properties. "ObservableCollection" for example. Add "System.Collections.ObjectModel" to AdditionalNamespaces if setting the CollectionType = "ObservableCollection".
	Setting.NullableShortHand = true; //true => T?, false => Nullable<T>
	Setting.IncludeQueryTraceOn9481Flag = false; // If SqlServer 2014 appears frozen / take a long time when this file is saved, try setting this to true (you will also need elevated privileges).
	Setting.PrivateSetterForComputerColumns = true; // If the columns is computed, use a private setter.

	string[] AdditionalNamespaces = new[] { "" };  // To include extra namespaces, include them here. i.e. "Microsoft.AspNet.Identity.EntityFramework"

	string[] AdditionalContextInterfaceItems = new[] // To include extra db context interface items, include them here. Also set MakeClassesPartial=true, and implement the partial DbContext class functions.
	{
		""  //  example: "void SetAutoDetectChangesEnabled(bool flag);"
	};

	// If you need to serialize your entities with the JsonSerializer from Newtonsoft, this would serialize
	// all properties including the Reverse Navigation and Foreign Keys. The simplest way to exclude them is
	// to use the data annotation [JsonIgnore] on reverse navigation and foreign keys.
	string[] AdditionalReverseNavigationsDataAnnotations = new string[] // Data Annotations for ReverseNavigationProperty.
	{
		// "JsonIgnore"
	};

	string[] AdditionalForeignKeysDataAnnotations = new string[] // Data Annotations for ForeignKeys.
	{
		// "JsonIgnore"
	};

	ContextProjectName = "Tiger.Dal";
	ContextFolderName = "Context";
	ConfigurationProjectName = "Tiger.Dal";
	ConfigurationFolderName = "Configurations";
	ModelProjectName = "Tiger.DataModel";
	ModelFolderName = "Models";
	ModelInterfaceProjectName = "Tiger.DataModel";
	ModelInterfaceFolderName = "Interfaces";
	RepositoryProjectName = "Tiger.Dal";
	RepositoryFolderName = "Repositories";
	RepositoryInterfaceProjectName = "Tiger.Dal";
	RepositoryInterfaceFolderName = "Interfaces";

	TableNames = new List<string>();
	StoredProcedureNames = new List<string>();

	InitConnectionString();
	ReversePocoCore.ProcessDatabaseXML(Host.TemplateFile, ref TableNames, ref StoredProcedureNames);
	
	using (Tiger.Dal.UpdateFromDatabase frm = new Tiger.Dal.UpdateFromDatabase(ConnectionString, TableNames, StoredProcedureNames, Setting))
	{
		frm.ShowDialog();

		Setting = frm.Setting;
		TableNames = frm.TableNames;
		StoredProcedureNames = frm.StoredProcedureNames;
	}


	// Elements to generate ***************************************************************************************************************
	// Add the elements that should be generated when the template is executed.
	// Multiple projects can now be used that separate the different concerns.

	ElementsToGenerate = Elements.Poco;

	// Use these namespaces to specify where the different elements now live. These may even be in different assemblies.
	// Please note this does not create the files in these locations, it only adds a using statement to say where they are.
	// The way to do this is to add the "EntityFramework Reverse POCO Code First Generator" into each of these folders.
	// Then set the .tt to only generate the relevant section you need by setting
	//		ElementsToGenerate = Elements.Poco; in your Entity folder,
	//		ElementsToGenerate = Elements.Context | Elements.UnitOfWork; in your Context folder,
	//		ElementsToGenerate = Elements.PocoConfiguration; in your Maps folder.
	//		PocoNamespace = "YourProject.Entities";
	//		ContextNamespace = "YourProject.Context";
	//		UnitOfWorkNamespace = "YourProject.Context";
	//		PocoConfigurationNamespace = "YourProject.Maps";
	// You also need to set the following to the namespace where they now live:
	PocoNamespace = "Tiger.DataModel.Models";
	ContextNamespace = "Tiger.Dal.Context";
	UnitOfWorkNamespace = "Tiger.Dal";
	PocoConfigurationNamespace = "Tiger.Dal.Configurations";
	PocoInterfaceNamespace = "Tiger.DataModel.Interfaces";
	RepositoryNamespace = "Tiger.Dal.Repositories";
	RepositoryInterfaceNamespace = "Tiger.Dal.Interfaces";


	// Schema *****************************************************************************************************************************
	// If there are multiple schemas, then the table name is prefixed with the schema, except for dbo.
	// Ie. dbo.hello will be Hello.
	//	  abc.hello will be AbcHello.
	Setting.PrependSchemaName = true;	// Control if the schema name is prepended to the table name

	// Callbacks **********************************************************************************************************************
	// This method will be called right before we write the POCO header.
	Action<Table> WritePocoClassAttributes = t =>
	{
		// Do nothing by default
		// Example:
		// if(t.ClassName.StartsWith("Order"))
		//	  WriteLine("	 [SomeAttribute]");

		if(Setting.UseDataAnnotations)
		{
			WriteLine("[Table(\"{0}\", Schema = \"{1}\")]", t.Name, t.Schema);
		}
	};

	// Writes optional base classes
	Func<Table, string> WritePocoBaseClasses = t =>
	{
		//if (t.ClassName == "User")
		//	 return "IdentityUser<int, CustomUserLogin, CustomUserRole, CustomUserClaim>, ";
		return "";
	};

	// Writes any boilerplate stuff
	Action<Table> WritePocoBaseClassBody = t =>
	{
		// Do nothing by default
		// Example:
		// WriteLine("		  // " + t.ClassName);
	};

	Func<Column, string> WritePocoColumn = c =>
	{
		// Example of adding a [Required] data annotation attribute to all non-null fields
		//if (!c.IsNullable)
		//	 return "[System.ComponentModel.DataAnnotations.Required] " + c.Entity;

		StringBuilder sb = new StringBuilder();

		if(Setting.UseDataAnnotations)
		{
			if(c.IsIdentity)
				sb.AppendLine("[DatabaseGenerated(DatabaseGeneratedOption.Identity)]");
			if(c.IsComputed)
				sb.AppendLine("[DatabaseGenerated(DatabaseGeneratedOption.Computed)]");

			if(c.IsPrimaryKey)
				sb.AppendLine("[Key]");
			if(!c.IsNullable)
				sb.AppendLine("[Required]");
			if(!c.IsMaxLength && c.MaxLength > 0)
				sb.AppendLine(string.Format("[MaxLength({0})]", c.MaxLength));

			sb.AppendLine(string.Format("[Column(\"{0}\", TypeName=\"{1}\")]"
							,c.Name
							,c.SqlPropertyType
							//,c.IsPrimaryKey ? string.Format(", Order = {0}", c.PrimaryKeyOrdinal) : ""
						));
		}

		sb.AppendLine(c.Entity);

		return sb.ToString();
	};

	Func<Column, string> WritePocoInterfaceColumn = c =>
	{
		// Example of adding a [Required] data annotation attribute to all non-null fields
		//if (!c.IsNullable)
		//	 return "[System.ComponentModel.DataAnnotations.Required] " + c.Entity;

		return c.InterfaceEntity;
	};

	// ***********************************************************************
	// ** Experienced developers only below this point

	Func<StoredProcedure, string> WriteStoredProcFunctionName = sp => sp.NameHumanCase;

	Func<StoredProcedure, bool> StoredProcHasOutParams = (sp) =>
	{
		return sp.Parameters.Any(x => x.Mode != StoredProcedureParameterMode.In);
	};

	Func<StoredProcedure, bool, string> WriteStoredProcFunctionParams = (sp, includeProcResult) =>
	{
		var sb = new StringBuilder();
		int n = 1;
		int count = sp.Parameters.Count;
		foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
		{
			sb.AppendFormat("{0}{1}{2} {3}{4}",
					p.Mode == StoredProcedureParameterMode.In ? "" : "out ",
					p.PropertyType,
					ReversePocoCore.NotNullable.Contains(p.PropertyType.ToLower()) ? string.Empty : "?",
					p.NameHumanCase,
					(n++ < count) ? ", " : string.Empty);
		}
		if (includeProcResult && sp.ReturnModels.Count > 0 && sp.ReturnModels.First().Count > 0)
			sb.AppendFormat((sp.Parameters.Count > 0 ?  ", " : "") + "out int procResult");
		return sb.ToString();
	};

	Func<StoredProcedure, string> WriteStoredProcFunctionOverloadCall = (sp) =>
	{
		var sb = new StringBuilder();
		foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
		{
			sb.AppendFormat("{0}{1}, ",
					p.Mode == StoredProcedureParameterMode.In ? "" : "out ",
					p.NameHumanCase);
		}
		sb.Append("out procResult");
		return sb.ToString();
	};

	Func<StoredProcedure, string> WriteStoredProcFunctionSqlAtParams = sp =>
	{
		var sb = new StringBuilder();
		int n = 1;
		int count = sp.Parameters.Count;
		foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
		{
			sb.AppendFormat("{0}{1}{2}",
					p.Name,
					p.Mode == StoredProcedureParameterMode.In ? string.Empty : " OUTPUT",
					(n++ < count) ? ", " : string.Empty);
		}
		return sb.ToString();
	};

	Func<StoredProcedureParameter, string> WriteStoredProcSqlParameterName = p => p.NameHumanCase + "Param";

	Func<StoredProcedure, bool, string> WriteStoredProcFunctionDeclareSqlParameter = (sp, includeProcResult) =>
	{
		var sb = new StringBuilder();
		foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
		{
			bool isNullable = !ReversePocoCore.NotNullable.Contains(p.PropertyType.ToLower());
			var getValueOrDefault = isNullable ? ".GetValueOrDefault()" : string.Empty;

			sb.AppendLine(string.Format("				var {0} = new System.Data.SqlClient.SqlParameter {{ ParameterName = \"{1}\", SqlDbType = System.Data.SqlDbType.{2}, Direction = System.Data.ParameterDirection.{3}{4}{5}{6}{7} }};",
					WriteStoredProcSqlParameterName(p),
					p.Name,
					p.SqlDbType,
					p.Mode == StoredProcedureParameterMode.In ? "Input" : "Output",
					p.Mode == StoredProcedureParameterMode.In ? ", Value = " + p.NameHumanCase + getValueOrDefault : string.Empty,
					p.MaxLength > 0 ? ", Size = " + p.MaxLength : string.Empty,
					(p.Precision > 0 || p.Scale > 0) ? ", Precision = " + p.Precision + ", Scale = " + p.Scale : string.Empty,
					p.PropertyType.ToLower().Contains("datatable") ? ", TypeName = \"" + p.UserDefinedTypeName + "\"" : string.Empty));

					if (p.Mode == StoredProcedureParameterMode.In)
					{
						sb.AppendFormat(
							isNullable
									? "				if (!{0}.HasValue){1}					 {0}Param.Value = System.DBNull.Value;{1}{1}"
									: "				if ({0}Param.Value == null){1}					 {0}Param.Value = System.DBNull.Value;{1}{1}",
							p.NameHumanCase, Environment.NewLine);
					}
		}
		if(includeProcResult && sp.ReturnModels.Count < 2)
			sb.AppendLine("				var procResultParam = new System.Data.SqlClient.SqlParameter { ParameterName = \"@procResult\", SqlDbType = System.Data.SqlDbType.Int, Direction = System.Data.ParameterDirection.Output };");
		return sb.ToString();
	};

	Func<StoredProcedure, string> WriteTableValuedFunctionDeclareSqlParameter = sp =>
	{
		var sb = new StringBuilder();
		foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
		{
			sb.AppendLine(string.Format("				var {0}Param = new System.Data.Entity.Core.Objects.ObjectParameter(\"{1}\", typeof({2})) {{ Value = {3} }};",
					p.NameHumanCase,
					p.Name.Substring(1),
					p.PropertyType,
					p.NameHumanCase + (p.Mode == StoredProcedureParameterMode.In && ReversePocoCore.NotNullable.Contains(p.PropertyType.ToLowerInvariant()) ? string.Empty : ".GetValueOrDefault()" )));
		}
		return sb.ToString();
	};

	Func<StoredProcedure, bool, string> WriteStoredProcFunctionSqlParameterAnonymousArray = (sp, includeProcResultParam) =>
	{
		var sb = new StringBuilder();
		bool hasParam = false;
		foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
		{
			sb.Append(string.Format("{0}Param, ", p.NameHumanCase));
			hasParam = true;
		}
		if (includeProcResultParam)
			sb.Append("procResultParam");
		else if(hasParam)
			sb.Remove(sb.Length - 2, 2);
		return sb.ToString();
	};

	Func<StoredProcedure, string> WriteTableValuedFunctionSqlParameterAnonymousArray = sp =>
	{
		if (sp.Parameters.Count == 0)
			return "new System.Data.Entity.Core.Objects.ObjectParameter[] { }";
		var sb = new StringBuilder();
		foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
		{
			sb.Append(string.Format("{0}Param, ", p.NameHumanCase));
		}
		return sb.ToString().Substring(0, sb.Length - 2);
	};

	Func<StoredProcedure, bool, string> WriteStoredProcFunctionSetSqlParameters = (sp, isFake) =>
	{
		var sb = new StringBuilder();
		foreach (var p in sp.Parameters.Where(x => x.Mode != StoredProcedureParameterMode.In).OrderBy(x => x.Ordinal))
		{
			string Default = string.Format("default({0})", p.PropertyType);
			bool notNullable = ReversePocoCore.NotNullable.Contains(p.PropertyType.ToLower());

			if(isFake)
					sb.AppendLine(string.Format("				{0} = {1};", p.NameHumanCase, Default));
			else
			{
					sb.AppendLine(string.Format("				if (IsSqlParameterNull({0}Param))", p.NameHumanCase));
					sb.AppendLine(string.Format("					 {0} = {1};", p.NameHumanCase, notNullable ? Default : "null"));
					sb.AppendLine("				else");
					sb.AppendLine(string.Format("					 {0} = ({1}) {2}Param.Value;", p.NameHumanCase, p.PropertyType, p.NameHumanCase));
			}
		}
		return sb.ToString();
	};

	Func<StoredProcedure, string> WriteStoredProcReturnModelName = sp =>
		ReversePocoCore.StoredProcedureReturnTypes.ContainsKey(sp.NameHumanCase)
			? ReversePocoCore.StoredProcedureReturnTypes[sp.NameHumanCase]
			: ReversePocoCore.StoredProcedureReturnTypes.ContainsKey(sp.Name)
					? ReversePocoCore.StoredProcedureReturnTypes[sp.Name]
					: string.Format("{0}ReturnModel", sp.NameHumanCase);

	Func<DataColumn, string> WriteStoredProcReturnColumn = col =>
		string.Format("public {0} {1} {{ get; set; }}",
			StoredProcedure.WrapTypeIfNullable("System." + col.DataType.Name,col), col.ColumnName);

	Func<StoredProcedure, string> WriteStoredProcReturnType = (sp) =>
	{
		var returnModelCount = sp.ReturnModels.Count;
		if (returnModelCount == 0)
			return "int";

		var spReturnClassName = WriteStoredProcReturnModelName(sp);
		return (returnModelCount == 1) ? string.Format("System.Collections.Generic.List<{0}>", spReturnClassName) : spReturnClassName;
	};

	System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();

	sw.Start();
	// Read schema
	ReversePocoCore reversePocoCore = new ReversePocoCore(Setting);
	
	var factory = GetDbProviderFactory();
	var tables = reversePocoCore.LoadTables(factory, ConnectionString, TableNames);
	var storedProcs = reversePocoCore.LoadStoredProcs(factory, ConnectionString, StoredProcedureNames);

	// Generate output
	if (tables.Count > 0 || storedProcs.Count > 0)
	{
#>
<#@ include file="EF.Reverse.POCO.ttinclude" #>
<#@ import namespace="System.Xml.Schema" #>
<# }

sw.Stop();
WriteLine(string.Format("// Total Elapsed Time: {0}",sw.Elapsed.TotalSeconds.ToString()));
 #>