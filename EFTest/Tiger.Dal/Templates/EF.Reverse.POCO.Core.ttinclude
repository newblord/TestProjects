<#
// Copyright (C) Simon Hughes 2012
// v2.22.1
#>
<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ include file="EF6.Utility.CS.ttinclude"#>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.Data.Common" #>
<#@ import namespace="System.Data.Entity.Infrastructure.Pluralization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Windows.Forms" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="Tiger.Dal.Templates.DatabaseObjects" #>
<#@ include file="TemplateFileManager.ttinclude" #>
<#@ assembly name="$(SolutionDir)\Tiger.Dal\bin\Debug\Tiger.Dal.dll" #>
<#@ output extension=".cs"#>
<#

	var code = new CodeGenerationTools(this);
	string Namespace = code.VsNamespaceSuggestion() ?? "DebugMode";

	DatabaseGenerationSetting Setting = new DatabaseGenerationSetting();

	Setting.DatabaseContextName = "MyDbContext";
	Setting.ContextInterfaceBaseClass = "System.IDisposable";
	Setting.ContextBaseClass = "System.Data.Entity.DbContext";
	Setting.MakeClassesPartial = true;
	Setting.MakeInterfacesPartial = true;
	Setting.MakeContextInterfacePartial = false;
	Setting.GenerateSeparateFiles = false;
	Setting.UseDataAnnotations = false;
	Setting.GenerateContextClass = true;
	Setting.GenerateUnitOfWorkInterface = true;
	Setting.VirtualReverseNavigationProperties = false;
	Setting.UseCamelCase = true;
	Setting.DisableGeographyTypes = false;
	Setting.NullableShortHand = true;
	Setting.PrivateSetterForComputedColumns = true;
	Setting.FileExtension = ".cs";
	Setting.GeneratedFileExtension = ".generated.cs";
	Setting.PrependSchemaName = true;
	Setting.ConfigurationClassName = "Configuration";
	Setting.IncludeComments = CommentsStyle.AtEndOfField;
	Setting.IncludeQueryTraceOn9481Flag = false;

#>
<#+

	// Settings - edit these in the main <name>.tt file *******************************************************************************
	string ConnectionStringName = "";
	string _defaultConstructorArgument = null;
	string DefaultConstructorArgument {get {return _defaultConstructorArgument ?? String.Format('"' + "Name={0}" + '"',ConnectionStringName);} set {_defaultConstructorArgument = value;}}

	string[] ConfigFilenameSearchOrder = null;

	private string _connectionString = "";
	private string _providerName = "";
	private string _configFilePath = "";

	string ContextProjectName, ContextFolderName, ConfigurationProjectName, ConfigurationFolderName, ModelProjectName, ModelFolderName,
				ModelInterfaceProjectName, ModelInterfaceFolderName, RepositoryProjectName, RepositoryFolderName, RepositoryInterfaceProjectName, 
				RepositoryInterfaceFolderName, ServiceProjectName, ServiceFolderName, ServiceInterfaceProjectName, ServiceInterfaceFolderName = "";

	List<TableData> TableNames = null;
	List<string> StoredProcedureNames = null;

	// Settings to allow selective code generation
	

	string PocoNamespace, ContextNamespace, UnitOfWorkNamespace, 
				PocoConfigurationNamespace, PocoInterfaceNamespace, 
				RepositoryNamespace, RepositoryInterfaceNamespace,
				ServiceNamespace, ServiceInterfaceNamespace = "";

	// Settings to allow TargetFramework checks
	private static string TargetFrameworkVersion;
	Func<string,bool> IsSupportedFrameworkVersion = (string frameworkVersion) =>
	{
		if (!string.IsNullOrEmpty(TargetFrameworkVersion))
		{
			var nfi = CultureInfo.InvariantCulture.NumberFormat;
			float target = float.Parse(TargetFrameworkVersion, nfi);
			float isSupported = float.Parse(frameworkVersion, nfi);
			return isSupported <= target;
		}
		return true;
	};

	public const string DataDirectory = "|DataDirectory|";

	public string ConnectionString
	{
		get
		{
			return _connectionString;
		}
	}

	public string ProviderName
	{
		get
		{
			return _providerName;
		}
	}

	public static void ArgumentNotNull<T>(T arg, string name) where T : class
	{
		if (arg == null)
		{
			throw new ArgumentNullException(name);
		}
	}

	private string GetConnectionString(ref string connectionStringName, out string providerName, out string configFilePath)
	{
		providerName = null;
		configFilePath = String.Empty;
		string result = "";
		var paths = GetConfigPaths();

		// Find a configuration file with the named connection string
		foreach (var path in paths)
		{
			var configFile = new ExeConfigurationFileMap { ExeConfigFilename = path };
			var config = System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(configFile, ConfigurationUserLevel.None);
			var connSection = config.ConnectionStrings;

			if (string.IsNullOrEmpty(connectionStringName))
				continue;

			// Get the named connection string
			try
			{
				result = connSection.ConnectionStrings[connectionStringName].ConnectionString;
				providerName = connSection.ConnectionStrings[connectionStringName].ProviderName;
				configFilePath = path;
				return result;  // found it
			}
			catch
			{
				result = "There is no connection string name called '" + connectionStringName + "'";
			}
		}
		return result;
	}

	private void InitConnectionString()
	{
		if(!String.IsNullOrEmpty(_connectionString))
			return;

		_connectionString = GetConnectionString(ref ConnectionStringName, out _providerName, out _configFilePath);

		if(!_connectionString.Contains(DataDirectory))
			return;

		// Replace data directory path
		string dataFilePath = GetDataDirectory();
		_connectionString = _connectionString.Replace(DataDirectory, dataFilePath);
	}

	public EnvDTE.DTE GetDTE()
	{
		var serviceProvider = (IServiceProvider)Host;
		if(serviceProvider == null)
			throw new Exception("Host property returned unexpected value (null)");

		var dte = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
		if(dte == null)
			throw new Exception("Unable to retrieve EnvDTE.DTE");

		return dte;
	}

	public EnvDTE.Solution GetSolution()
	{
		return GetDTE().Solution;
	}

	public IEnumerable<EnvDTE.Project> GetAllProjects()
	{
		foreach(var projectObj in GetSolution().Projects)
		{
			var project = projectObj as EnvDTE.Project;
			if(project == null)
				continue;
			if(project.Kind == EnvDTE.Constants.vsProjectKindSolutionItems)
				foreach(var p in RecurseSolutionFolder(project))
					yield return p;
			else
				yield return project;
		}
	}

	private IEnumerable<EnvDTE.Project> RecurseSolutionFolder(EnvDTE.Project project)
	{
		if (project.ProjectItems == null)
			yield break;

		foreach (EnvDTE.ProjectItem projectItem in project.ProjectItems)
		{
			var subProject = projectItem.SubProject;
			if (subProject == null)
				continue;
			if (subProject.Kind == EnvDTE.Constants.vsProjectKindSolutionItems)
			{
				foreach (var p in RecurseSolutionFolder(subProject))
					yield return p;
			}
			else
				yield return subProject;
		}
	}

	public EnvDTE.Project GetCurrentProject()
	{
		var dte = GetDTE();
		var activeSolutionProjects = (Array)dte.ActiveSolutionProjects;
		if(activeSolutionProjects == null)
			throw new Exception("DTE.ActiveSolutionProjects returned null");

		if (activeSolutionProjects.Length > 0)
		{
			var dteProject = (EnvDTE.Project) activeSolutionProjects.GetValue(0);
			if (dteProject != null)
				return dteProject;
		}

		var item = dte.Solution.FindProjectItem(Host.TemplateFile);
		if (item != null && item.ContainingProject != null)
			return item.ContainingProject;

		throw new InvalidOperationException("Error in GetCurrentProject(). Unable to find project.");
	}

	private string GetProjectPath(EnvDTE.Project project)
	{
		var fullProjectName = project.FullName;

		if (string.IsNullOrWhiteSpace(fullProjectName))
			return string.Empty;

		try
		{
			var info = new FileInfo(fullProjectName);
			return info.Directory == null ? string.Empty : info.Directory.FullName;
		}
		catch{
			WriteLine("// Project " + fullProjectName + " excluded.");
			return string.Empty;
		}
	}

	private List<string> GetConfigPaths()
	{
		var paths = new List<string>();

		// Local project first
		EnvDTE.Project project = GetCurrentProject();
		paths.AddRange(GetConfigPathsInProject(project));

		// Then other projects next
		var projects = GetAllProjects();
		foreach (EnvDTE.Project dteProject in projects)
		{
			paths.AddRange(GetConfigPathsInProject(dteProject));
		}

		if (!paths.Any() && ConfigFilenameSearchOrder != null)
		{
			var sln = GetSolution();
			paths.AddRange(
				ConfigFilenameSearchOrder
				.Select(sln.FindProjectItem)
				.Where(item => item != null)
				.Select(item => item.FileNames[0]));
		}

		return paths;
	}

	private List<string> GetConfigPathsInProject(EnvDTE.Project project)
	{
		var paths = new List<string>();
		if (ConfigFilenameSearchOrder == null || project == null)
			return paths;

		foreach (string filename in ConfigFilenameSearchOrder)
		{
			paths.AddRange(GetConfigPathsInProjectForFile(project, filename));
		}

		return paths;
	}

	private List<string> GetConfigPathsInProjectForFile(EnvDTE.Project project, string filename)
	{
		try
		{
			if (project == null || project.Kind == EnvDTE.Constants.vsProjectKindUnmodeled)
			{
				// Project is 'unloaded'
				return new List<string>();
			}

			return (from ProjectItem item in project.ProjectItems
					where item.Name.Equals(filename, StringComparison.InvariantCultureIgnoreCase)
					select Path.Combine(GetProjectPath(project), item.Name))
					.ToList();
		}
		catch (Exception)
		{
				return new List<string>();
		}
	}

	// Search for the database file
	public string GetDataDirectory()
	{
		var factory = TryGetDbProviderFactory();
		if (factory != null)
		{
			var paths = GetConfigPaths();
			paths.Add(GetSolution().FullName);
			using (DbConnection conn = factory.CreateConnection())
			{
				foreach (var path in paths)
				{
					try
					{
							var directory = Path.GetDirectoryName(path) + "\\";
							var connStr = _connectionString.Replace(DataDirectory, directory);
							conn.ConnectionString = connStr;
							conn.Open();
							return directory;	// Successfully opened the database. Return the datapath where we found it
					}
					catch (Exception)
					{
							// Could not open the database. Eat error, and try next path
					}
				}
			}
		}

		// Fall back to default
		var project = GetCurrentProject();
		return Path.GetDirectoryName(project.FileName) + "\\App_Data\\";
	}

	private static string ZapPassword(string connectionString)
	{
		var rx = new Regex("password=[^\";]*", RegexOptions.Singleline | RegexOptions.Multiline | RegexOptions.IgnoreCase);
		return rx.Replace(connectionString, "password=**zapped**;");
	}

	private DbProviderFactory GetDbProviderFactory()
	{
		InitConnectionString();

		try
		{
			return DbProviderFactories.GetFactory(ProviderName);
		}
		catch (Exception x)
		{
			string error = x.Message.Replace("\r\n", "\n").Replace("\n", " ");
			Warning(string.Format("Failed to load provider \"{0}\" - {1}", ProviderName, error));
			WriteLine("");
			WriteLine("// ------------------------------------------------------------------------------------------------");
			WriteLine("// Failed to load provider \"{0}\" - {1}", ProviderName, error);
			WriteLine("// ------------------------------------------------------------------------------------------------");
			WriteLine("");
			return null;
		}
	}

	private DbProviderFactory TryGetDbProviderFactory()
	{
		try
		{
			return DbProviderFactories.GetFactory(ProviderName);
		}
		catch (Exception)
		{
			return null;
		}
	}

#>